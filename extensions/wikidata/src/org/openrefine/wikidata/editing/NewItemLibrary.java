package org.openrefine.wikidata.editing;

import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;

import com.google.refine.model.Project;
import com.google.refine.model.Cell;
import com.google.refine.model.Column;
import com.google.refine.model.Recon;
import com.google.refine.model.ReconCandidate;
import com.google.refine.model.ReconStats;

import org.openrefine.wikidata.schema.NewEntityIdValue;

/**
 * This keeps track of the new items that we
 * have created for each cell that was marked
 * as such.
 * 
 * @author antonin
 *
 */
public class NewItemLibrary {
    
    private Map<CellCoordinates, String> map;
    
    public NewItemLibrary() {
        map = new HashMap<>();
    }
    
    /**
     * Retrieves the Qid allocated to a given new cell
     * @param id: the fake ItemId generated by the cell
     * @return the qid (or null if unallocated yet)
     */
    public String getQid(NewEntityIdValue id) {
        return map.get(fromNewEntityIdValue(id));
    }
    
    /**
     * Stores a Qid associated to a new cell
     * @param id : the fake EntityIdValue generated by the cell
     * @param qid : the associated Qid returned by Wikibase
     */
    public void setQid(NewEntityIdValue id, String qid) {
        map.put(fromNewEntityIdValue(id), qid);
    }
    
    /**
     * Changes the "new" reconciled cells to their allocated
     * qids for later use.
     * 
     * @param reset: set to true to revert the operation (set cells to "new")
     */
    public void updateReconciledCells(Project project, boolean reset) {
        Set<Integer> impactedColumns = new HashSet<>();
        
        for(Map.Entry<CellCoordinates, String> entry : map.entrySet()) {
            CellCoordinates coords = entry.getKey();
            Cell cell = project.rows.get(coords.row).getCell(coords.col);
            Recon recon = cell.recon;
            if (recon.judgment.equals(Recon.Judgment.New) && !reset) {
                recon.judgment = Recon.Judgment.Matched;
                recon.match = new ReconCandidate(
                        entry.getValue(),
                        cell.value.toString(),
                        new String[0],
                        100);
            } else if (recon.judgment.equals(Recon.Judgment.Matched) && reset) {
                recon.judgment = Recon.Judgment.New;
                recon.match = null;
            }
            impactedColumns.add(coords.col);
        }
        
        // Update reconciliation statistics for impacted columns
        for(Integer colId : impactedColumns) {
            Column column = project.columnModel.getColumnByCellIndex(colId);
            column.setReconStats(ReconStats.create(project, colId));
        }
    }
    
    // TODO migrate NewEntityIdValue to use CellCoordinates directly
    private CellCoordinates fromNewEntityIdValue(NewEntityIdValue id) {
        return new CellCoordinates(id.getRowId(), id.getColId());
    }
    
    /**
     * Accessor, only meant to be used by Jackson
     * @return the underlying map
     */
    public Map<CellCoordinates, String> getQidMap() {
        return map;
    }
    
    /**
     * Accessor, only meant to be used by Jackson
     */
    public void setQidMap(Map<CellCoordinates, String> newMap) {
        map = newMap;
    }
}
