
package org.openrefine.model;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.openrefine.model.changes.RecordChangeDataProducer;
import org.openrefine.model.changes.RowChangeDataProducer;
import org.openrefine.operations.RowMapOperation;

/**
 * Represents a local function applied to each row of the project, generally generated by a {@link RowMapOperation}.
 * <p>
 * It can be used as:
 * <ul>
 * <li>a {@link RowMapper} if the function is cheap to compute (meaning that the results do not need persisting) and
 * does not require access to the containing record of each row</li>
 * <li>a {@link RecordMapper} if the function is cheap to compute and relies access to the containing record</li>
 * <li>a {@link RowChangeDataProducer} if the results should be persisted and the function is purely row-wise</li>
 * <li>a {@link RecordChangeDataProducer} otherwise
 * </ul>
 * The {@link #getBatchSize()} method can be used to configure the size of the batches with which the change data
 * producers are called. Similarly, {@link #getMaxConcurrency()} can be used to cap the number of concurrent computation
 * processes for this operation. Those methods are ignored if the results should not be persisted.
 */
public abstract class RowInRecordMapper
        implements RowMapper, RecordMapper, RowChangeDataProducer<Row>, RecordChangeDataProducer<List<Row>> {

    private static final long serialVersionUID = -2751707283001756980L;

    /**
     * Computes the function a row, optionally in the context of its enclosing record.
     * 
     * @param record
     *            the record enclosing the row to map, if it is available (null otherwise)
     * @param rowId
     *            the global index of the row in the entire grid
     * @param row
     *            the row itself
     */
    public abstract Row call(Record record, long rowId, Row row);

    /**
     * Is this mapper guaranteed to preserve the records structure, both as a record mapper and a row mapper?
     */
    @Override
    public abstract boolean preservesRecordStructure();

    /**
     * Computes the function on a batch of rows, as a batched version of {@link #call(Record, long, Row)}. The supplied
     * lists must all have the same size. By default, this just calls {@link #call(Record, long, Row)} for each element
     * of the batch, but implementations can override that to take advantage of the batching.
     */
    public List<Row> callRowBatch(List<Record> records, List<IndexedRow> indexedRows) {
        List<Row> results = new ArrayList<>(indexedRows.size());
        for (int i = 0; i != indexedRows.size(); i++) {
            IndexedRow indexedRow = indexedRows.get(i);
            results.add(call(records.get(i), indexedRow.getIndex(), indexedRow.getRow()));
        }
        return results;
    }

    /**
     * Batched version of {@link #call(Record)}. By default, this just calls {@link #call(Record)} for each record in
     * the batch, but implementations can override that to take advantage of the batching.
     */
    public List<List<Row>> callRecordBatch(List<Record> records) {
        return records.stream()
                .map(record -> call(record))
                .collect(Collectors.toList());
    }

    // Methods from RowMapper

    @Override
    public Row call(long rowId, Row row) {
        return call(null, rowId, row);
    }

    // Methods from RecordMapper

    @Override
    public List<Row> call(Record record) {
        List<Row> rows = record.getRows();
        List<Row> results = new ArrayList<>(rows.size());
        for (int i = 0; i != rows.size(); i++) {
            results.add(call(record, record.getStartRowId() + i, rows.get(i)));
        }
        return results;
    }

    @Override
    public boolean preservesRowCount() {
        return true;
    }

    // Methods from RowChangeDataProducer

    @Override
    public Row call(long rowId, Row row, ColumnModel columnModel) {
        return call(null, rowId, row);
    }

    @Override
    public List<Row> callRowBatch(List<IndexedRow> rows, ColumnModel columnModel) {
        List<Record> records = rows.stream().map(t -> (Record) null).collect(Collectors.toList());
        return callRowBatch(records, rows);
    }

    // Methods from RecordChangeDataProducer

    @Override
    public List<Row> call(Record record, ColumnModel columnModel) {
        return call(record);
    }

    @Override
    public List<List<Row>> callRecordBatch(List<Record> records, ColumnModel columnModel) {
        return callRecordBatch(records);
    }

    // Methods from both RowChangeDataProducer and RecordChangeDataProducer

    @Override
    public int getBatchSize() {
        return 1;
    }

    @Override
    public int getMaxConcurrency() {
        return 0;
    }

    @Override
    public List<ColumnId> getColumnDependencies() {
        return null;
    }

    public static RowInRecordMapper fromRowMapper(RowMapper rowMapper) {
        return new RowInRecordMapper() {

            private static final long serialVersionUID = -985327238622556721L;

            @Override
            public Row call(Record record, long rowId, Row row) {
                return rowMapper.call(rowId, row);
            }

            @Override
            public boolean preservesRecordStructure() {
                return rowMapper.preservesRecordStructure();
            }

        };
    }

    public final static RowInRecordMapper IDENTITY = fromRowMapper(RowMapper.IDENTITY);

}
