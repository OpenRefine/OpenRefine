

# Functions
# 1. Arrays
arr_args_to_array=Vrac\u00ED v\u0161echny p\u0159edan\u00E9 argumenty jako pole
arr_in_array=Vrac\u00ED true, pokud pole obsahuje po\u017Eadovan\u00FD \u0159et\u011Bzec, a false v opa\u010Dn\u00E9m p\u0159\u00EDpad\u011B. Neprov\u00E1d\u00ED konverzi datov\u00FDch typ\u016F.
arr_join=Spoj\u00ED polo\u017Eky v poli pomoc\u00ED sep a vr\u00E1t\u00ED je v\u0161echny jako \u0159et\u011Bzec.
arr_reverse=Obr\u00E1t\u00ED pole a.
arr_sort=Se\u0159ad\u00ED pole vzestupn\u011B. P\u0159i \u0159azen\u00ED se rozli\u0161uj\u00ED velk\u00E1 a mal\u00E1 p\u00EDsmena.
arr_uniques=Vrac\u00ED pole s odstran\u011Bn\u00FDmi duplicitami. Rozli\u0161uje velk\u00E1 a mal\u00E1 p\u00EDsmena.
arr_zip=Slou\u010D\u00ED dv\u011B nebo v\u00EDce pol\u00ED do jedin\u00E9ho pole pol\u00ED, p\u0159i\u010Dem\u017E prvky se stejn\u00FDm indexem ze vstupn\u00EDch pol\u00ED se seskup\u00ED a vytvo\u0159\u00ED d\u00EDl\u010D\u00ED pole ve v\u00FDstupn\u00EDm poli.
bool_or=Pou\u017E\u00EDv\u00E1 logick\u00FD oper\u00E1tor OR na dvou nebo v\u00EDce logick\u00FDch \u010D\u00EDslech k vytvo\u0159en\u00ED logick\u00E9ho \u010D\u00EDsla. Nap\u0159\u00EDklad (1 < 3).or(1 > 7) vr\u00E1t\u00ED true, proto\u017Ee alespo\u0148 jedna z podm\u00EDnek (prvn\u00ED) je pravdiv\u00E1.
bool_not=Pou\u017E\u00EDv\u00E1 logick\u00FD oper\u00E1tor NOT na logick\u00E9m prvku k v\u00FDstupu logick\u00E9ho prvku. Nap\u0159\u00EDklad not(1 > 7) vr\u00E1t\u00ED true, proto\u017Ee 1 > 7 je nepravda.
bool_xor=Pou\u017E\u00EDv\u00E1 logick\u00FD oper\u00E1tor XOR (exkluzivn\u00ED nebo) na dva nebo v\u00EDce logick\u00FDch symbol\u016F, \u010D\u00EDm\u017E vytvo\u0159\u00ED logick\u00FD symbol. Vyhodnot\u00ED v\u00EDce v\u00FDrok\u016F a vr\u00E1t\u00ED true, pokud je pravdiv\u00FD pouze jeden z nich. Nap\u0159\u00EDklad (1 < 3).xor(1 < 7) vr\u00E1t\u00ED false, proto\u017Ee v\u00EDce ne\u017E jedna z podm\u00EDnek je pravdiv\u00E1.
date_inc=Vrac\u00ED datum zm\u011Bn\u011Bn\u00E9 o danou hodnotu v dan\u00E9 \u010Dasov\u00E9 jednotce v uvozovk\u00E1ch. Tabulku naleznete na adrese https://openrefine.org/docs/manual/grelfunctions/#incd-n-s-timeunit. V\u00FDchoz\u00ED jednotkou je ''hodina''. Kladn\u00E1 hodnota datum zv\u011Bt\u0161\u00ED a z\u00E1porn\u00E1 hodnota jej posune v \u010Dase zp\u011Bt.
math_abs=Vrac\u00ED absolutn\u00ED hodnotu \u010D\u00EDsla.
math_acos=Vrac\u00ED obloukov\u00FD kosinus \u00FAhlu v rozsahu 0 a\u017E PI.
math_asin=Vr\u00E1t\u00ED obloukov\u00FD sinus \u00FAhlu v rozsahu -PI/2 a\u017E PI/2.
math_atan=Vrac\u00ED obloukovou te\u010Dnu \u00FAhlu v rozsahu -PI/2 a\u017E PI/2.
math_atan2=P\u0159evede pravo\u00FAhl\u00E9 sou\u0159adnice (n1, n2) na pol\u00E1rn\u00ED (r, theta). Vrac\u00ED \u010D\u00EDslo theta.
math_ceil=Vrac\u00ED horn\u00ED hranici \u010D\u00EDsla.
math_combin=Vrac\u00ED po\u010Det kombinac\u00ED pro n2 prvk\u016F rozd\u011Blen\u00FDch do n1.
math_cos=Vrac\u00ED trigonometrick\u00FD kosinus \u00FAhlu.
math_cosh=Vrac\u00ED hyperbolick\u00FD kosinus hodnoty.
math_degrees=P\u0159ev\u00E1d\u00ED \u00FAhel z radi\u00E1n\u016F na stupn\u011B.
math_even=Zaokrouhl\u00ED \u010D\u00EDslo nahoru na nejbli\u017E\u0161\u00ED sud\u00E9 cel\u00E9 \u010D\u00EDslo.
math_exp=Vrac\u00ED e na mocninu n.
math_fact=Vr\u00E1t\u00ED faktori\u00E1l \u010D\u00EDsla po\u010D\u00EDnaje 1.
math_factn=Vrac\u00ED faktori\u00E1l \u010D\u00EDsla n1, po\u010D\u00EDnaje \u010D\u00EDslem n2.
math_floor=Vrac\u00ED doln\u00ED hranici \u010D\u00EDsla.
math_gcd=Vr\u00E1t\u00ED nejv\u011Bt\u0161\u00ED spole\u010Dn\u00FD jmenovatel dvou \u010D\u00EDsel.
math_lcm=Vr\u00E1t\u00ED nejv\u011Bt\u0161\u00ED spole\u010Dn\u00FD jmenovatel dvou \u010D\u00EDsel.
bool_and=Pou\u017E\u00EDv\u00E1 logick\u00FD oper\u00E1tor AND na dvou nebo v\u00EDce logick\u00FDch soustav\u00E1ch k vytvo\u0159en\u00ED logick\u00E9 hodnoty. Vyhodnot\u00ED v\u00EDce v\u00FDrok\u016F na logick\u00E9 a vr\u00E1t\u00ED true, pokud jsou v\u0161echny v\u00FDroky pravdiv\u00E9. Nap\u0159\u00EDklad (1 < 3).a(1 < 0) vr\u00E1t\u00ED nepravdu, proto\u017Ee jedna podm\u00EDnka je pravdiv\u00E1 a druh\u00E1 nepravdiv\u00E1.
date_part=Vr\u00E1t\u00ED \u010D\u00E1st datumu. Vr\u00E1cen\u00FD typ dat z\u00E1vis\u00ED na jednotce. Tabulku naleznete na https://openrefine.org/docs/manual/grelfunctions/#datepartd-s-timeunit, https://openrefine.org/docs/manual/grelfunctions#date-functions.
date_now=Vr\u00E1t\u00ED aktu\u00E1ln\u00ED \u010Das podle syst\u00E9mov\u00FDch hodin v roz\u0161\u00ED\u0159en\u00E9m form\u00E1tu ISO 8601 (p\u0159evedeno na UTC). Nap\u0159\u00EDklad 10:53 (a 00 sekund) 26. listopadu 2020 v EST vr\u00E1t\u00ED [date 2020-11-26T15:53:00Z].
html_inner_html=Vrac\u00ED vnit\u0159n\u00ED HTML prvek HTML. Zahrnuje text a pod\u0159\u00EDzen\u00E9 prvky uvnit\u0159 vybran\u00E9ho prvku. Pou\u017Eijte jej ve spojen\u00ED s parseHtml() a select() pro poskytnut\u00ED prvku.
html_parse_html=P\u0159i zad\u00E1n\u00ED bu\u0148ky pln\u00E9 textu ve form\u00E1tu HTML funkce parseHtml() zjednodu\u0161\u00ED zna\u010Dky HTML (nap\u0159\u00EDklad odstran\u011Bn\u00EDm '' /'' na konci samouzav\u00EDrac\u00EDch zna\u010Dek), uzav\u0159e v\u0161echny neuzav\u0159en\u00E9 zna\u010Dky a vlo\u017E\u00ED zalomen\u00ED \u0159\u00E1dk\u016F a odr\u00E1\u017Eky, aby byl k\u00F3d \u010Dist\u0161\u00ED. Do bu\u0148ky nelze ulo\u017Eit v\u00FDstup funkce parseHtml(), pokud jej nep\u0159evedete pomoc\u00ED funkce toString(): nap\u0159\u00EDklad value.parseHtml().toString().
math_ln=Vrac\u00ED p\u0159irozen\u00FD logaritmus n.
math_log=Vrac\u00ED logaritmus n o z\u00E1kladu 10.
math_max=Vrac\u00ED v\u011Bt\u0161\u00ED ze dvou \u010D\u00EDsel.
math_min=Vrac\u00ED men\u0161\u00ED ze dvou \u010D\u00EDsel.
math_mod=Vrac\u00ED n1 modul n2.
math_multinomial=Vypo\u010D\u00EDt\u00E1 multinomick\u00FD sou\u010Din jednoho \u010D\u00EDsla nebo \u0159ady \u010D\u00EDsel.
math_odd=Zaokrouhl\u00ED \u010D\u00EDslo nahoru na nejbli\u017E\u0161\u00ED lich\u00E9 cel\u00E9 \u010D\u00EDslo.
math_pow=Vrac\u00ED n1 zv\u00FD\u0161en\u00E9 na mocninu n2.
math_quotient=Vr\u00E1t\u00ED celo\u010D\u00EDselnou \u010D\u00E1st d\u011Blen\u00ED (zkr\u00E1cenou, nezaokrouhlenou), pokud je zad\u00E1n \u010Ditatel a jmenovatel.
math_radians=P\u0159ev\u00E1d\u00ED \u00FAhel ve stupn\u00EDch na radi\u00E1ny.
math_random_number=Vr\u00E1t\u00ED n\u00E1hodn\u00E9 cel\u00E9 \u010D\u00EDslo v intervalu mezi doln\u00ED a horn\u00ED hranic\u00ED (v\u010Detn\u011B). Do ka\u017Ed\u00E9 bu\u0148ky ve sloupci vyp\u00ED\u0161e jin\u00E9 n\u00E1hodn\u00E9 \u010D\u00EDslo.
math_round=Zaokrouhl\u00ED \u010D\u00EDslo na nejbli\u017E\u0161\u00ED cel\u00E9 \u010D\u00EDslo.
math_sin=Vrac\u00ED trigonometrick\u00FD sinus \u00FAhlu.
math_sinh=Vrac\u00ED hyperbolick\u00FD sinus \u00FAhlu.
math_sum=Vr\u00E1t\u00ED sou\u010Det \u010D\u00EDsel v poli. Ignoruje polo\u017Eky, kter\u00E9 nejsou \u010D\u00EDsly. Vrac\u00ED 0, pokud pole neobsahuje \u010D\u00EDsla.
math_tan=Vrac\u00ED trigonometrick\u00FD tangens \u00FAhlu.
math_tanh=Vrac\u00ED hyperbolick\u00FD tangens \u00FAhlu.
str_decode=Dek\u00F3duje \u0159et\u011Bzec pomoc\u00ED zadan\u00E9ho k\u00F3dov\u00E1n\u00ED. Mezi k\u00F3dov\u00E1n\u00ED pat\u0159\u00ED Base16, Base32Hex, Base32, Base64 a Base64Url.
str_detect_language=Zjist\u00ED jazyk zadan\u00E9ho \u0159et\u011Bzce a poskytne k\u00F3d jazyka.
str_diff=Pro \u0159et\u011Bzce vezme dva \u0159et\u011Bzce, porovn\u00E1 je a vr\u00E1t\u00ED \u0159et\u011Bzec. Vr\u00E1t\u00ED zbytek \u0159et\u011Bzce o2 po\u010D\u00EDnaje prvn\u00EDm znakem, ve kter\u00E9m se li\u0161\u00ED. Pro data vr\u00E1t\u00ED rozd\u00EDl v dan\u00FDch \u010Dasov\u00FDch jednotk\u00E1ch. Viz tabulka \u010Dasov\u00FDch jednotek na adrese https://openrefine.org/docs/manual/grelfunctions/#datepartd-s-timeunit.
str_encode=Zak\u00F3duje \u0159et\u011Bzec pomoc\u00ED zadan\u00E9ho k\u00F3dov\u00E1n\u00ED. Mezi k\u00F3dov\u00E1n\u00ED pat\u0159\u00ED Base16, Base32Hex, Base32, Base64 a Base64Url.
str_escape=Escapuje s v dan\u00E9m escapovac\u00EDm m\u00F3du. Re\u017Eim m\u016F\u017Ee b\u00FDt jeden z n\u00E1sleduj\u00EDc\u00EDch: ''html'', ''xml'', csv'', ''url'', ''javascript''. V\u0161imn\u011Bte si, \u017Ee kolem zadan\u00E9ho re\u017Eimu jsou vy\u017Eadov\u00E1ny uvozovky.
str_ends_with=Vrac\u00ED boolean ur\u010Duj\u00EDc\u00ED, zda s kon\u010D\u00ED na sub. Nap\u0159\u00EDklad "food".endsWith("ood") vrac\u00ED true, zat\u00EDmco "food".endsWith("odd") vrac\u00ED false.
str_find=Vyp\u00ED\u0161e pole v\u0161ech po sob\u011B jdouc\u00EDch pod\u0159et\u011Bzc\u016F uvnit\u0159 \u0159et\u011Bzce s, kter\u00E9 odpov\u00EDdaj\u00ED pod\u0159et\u011Bzci nebo regexov\u00E9mu vzoru p. Pod\u0159et\u011Bzec m\u016F\u017Eete zadat tak, \u017Ee jej d\u00E1te do uvozovek. Viz tak\u00E9 match().
str_fingerprint=Vr\u00E1t\u00ED otisk s, \u0159et\u011Bzec, kter\u00FD je prvn\u00EDm krokem v metod\u00E1ch shlukov\u00E1n\u00ED otisk\u016F: o\u0159\u00EDzne b\u00EDl\u00E9 znaky, p\u0159evede v\u0161echny znaky na mal\u00E1 p\u00EDsmena, odstran\u00ED interpunkci, se\u0159ad\u00ED slova podle abecedy atd.
str_index_of=Vrac\u00ED index prvn\u00EDho znaku sub, jak se poprv\u00E9 vyskytuje v s; nebo vrac\u00ED -1, pokud s neobsahuje sub. Nap\u0159\u00EDklad "internationalization".indexOf("nation") vr\u00E1t\u00ED 5.
str_last_index_of=Vrac\u00ED index prvn\u00EDho znaku sub, jak se naposledy vyskytuje v s; nebo vrac\u00ED -1, pokud s neobsahuje sub. Nap\u0159\u00EDklad "parallel".lastIndexOf("a") vrac\u00ED 3 (ukazuje na druh\u00FD znak ''a'').
str_md5=Vrac\u00ED MD5 hash objektu. Pokud je zad\u00E1no n\u011Bco jin\u00E9ho ne\u017E \u0159et\u011Bzec (pole, \u010D\u00EDslo, datum atd.), funkce md5() jej p\u0159evede na \u0159et\u011Bzec a poskytne jeho hash.
str_ngram_fingerprint=Vrac\u00ED otisk n-gramu s.
str_ngram=Vrac\u00ED pole n-gram\u016F slov v \u0159et\u011Bzci s. To znamen\u00E1, \u017Ee uv\u00E1d\u00ED v\u0161echny mo\u017En\u00E9 po sob\u011B jdouc\u00ED kombinace n slov v \u0159et\u011Bzci.
str_parse_json=Parsuje \u0159et\u011Bzec jako JSON.
str_parse_uri=Parsuje identifik\u00E1tor URI a extrahuje jeho sou\u010D\u00E1sti.
str_partition=Vrac\u00ED pole \u0159et\u011Bzc\u016F [ a, fragment, z ], kde a je pod\u0159et\u011Bzec uvnit\u0159 s p\u0159ed prvn\u00EDm v\u00FDskytem fragmentu a z je pod\u0159et\u011Bzec za fragmentem. Fragment m\u016F\u017Ee b\u00FDt \u0159et\u011Bzec nebo regex. Pokud je omitFragment true, frag se nevrac\u00ED.
str_phonetic=Vrac\u00ED fonetick\u00E9 k\u00F3dov\u00E1n\u00ED \u0159et\u011Bzce na z\u00E1klad\u011B dostupn\u00E9ho fonetick\u00E9ho algoritmu. M\u016F\u017Ee to b\u00FDt jedna z n\u00E1sleduj\u00EDc\u00EDch podporovan\u00FDch fonetick\u00FDch metod: metaphone, doublemetaphone, metaphone3, soundex, cologne. V\u00FDchoz\u00ED hodnota je ''metaphone3''.
str_range=Vrac\u00ED pole, kde a a b je za\u010D\u00E1tek a konec rozsahu a c je krok (p\u0159\u00EDr\u016Fstek).
str_reinterpret=Vrac\u00ED s reinterpretovan\u00E9 pomoc\u00ED zadan\u00FDch k\u00F3dova\u010D\u016F znak\u016F. Pro ka\u017Ed\u00FD z p\u016Fvodn\u00EDch zdrojov\u00FDch a c\u00EDlov\u00FDch v\u00FDstup\u016F mus\u00EDte zadat jedno z podporovan\u00FDch k\u00F3dov\u00E1n\u00ED: https://docs.oracle.com/javase/1.5.0/docs/guide/intl/encoding.doc.html. V\u0161imn\u011Bte si, \u017Ee kolem k\u00F3dov\u00E1n\u00ED znak\u016F jsou vy\u017Eadov\u00E1ny uvozovky.
str_replace_each=Nahradit ka\u017Ed\u00FD v\u00FDskyt pod\u0159et\u011Bzce v \u0159et\u011Bzci jin\u00FDm pod\u0159et\u011Bzcem.
str_rpartition=Vrac\u00ED pole \u0159et\u011Bzc\u016F [ a, fragment, z ], kde a je pod\u0159et\u011Bzec v r\u00E1mci s p\u0159ed posledn\u00EDm v\u00FDskytem fragmentu a z je pod\u0159et\u011Bzec za posledn\u00EDm v\u00FDskytem fragmentu. Pokud je omitFragment true, fragment se nevrac\u00ED.
str_sha1=Vrac\u00ED hash SHA-1 objektu. Pokud je zad\u00E1no n\u011Bco jin\u00E9ho ne\u017E \u0159et\u011Bzec (pole, \u010D\u00EDslo, datum atd.), funkce sha1() jej p\u0159evede na \u0159et\u011Bzec a poskytne jeho hash.
str_smart_split=Vrac\u00ED pole \u0159et\u011Bzc\u016F z\u00EDskan\u00FDch rozd\u011Blen\u00EDm s podle sep nebo odhadem odd\u011Blov\u00E1n\u00ED tabul\u00E1torem nebo \u010D\u00E1rkou, pokud nen\u00ED sep zad\u00E1no. Spr\u00E1vn\u011B zpracov\u00E1v\u00E1 uvozovky a rozum\u00ED zru\u0161en\u00FDm znak\u016Fm. Odd\u011Blova\u010Dem m\u016F\u017Ee b\u00FDt bu\u010F \u0159et\u011Bzec, nebo regex vzorec.
str_split_by_char_type=Vrac\u00ED pole \u0159et\u011Bzc\u016F z\u00EDskan\u00FDch rozd\u011Blen\u00EDm s na skupiny po sob\u011B jdouc\u00EDch znak\u016F poka\u017Ed\u00E9, kdy\u017E se zm\u011Bn\u00ED kategorie Unicode.
str_split=Vrac\u00ED pole \u0159et\u011Bzc\u016F z\u00EDskan\u00FDch rozd\u011Blen\u00EDm s pomoc\u00ED sep. Odd\u011Blova\u010Dem m\u016F\u017Ee b\u00FDt bu\u010F \u0159et\u011Bzec, nebo regexov\u00FD vzor. Pokud je hodnota preserveTokens true, pr\u00E1zdn\u00E9 segmenty se zachovaj\u00ED.
str_starts_with=Vrac\u00ED logickou hodnotu ur\u010Duj\u00EDc\u00ED, zda s za\u010D\u00EDn\u00E1 na sub. Nap\u0159\u00EDklad \u201Efood\u201C.startsWith(\u201Efoo\u201C) vrac\u00ED true, zat\u00EDmco \u201Efood\u201C.startsWith(\u201Ebar\u201C) vrac\u00ED false.
str_to_lowercase=Vrac\u00ED \u0159et\u011Bzec s p\u0159eveden\u00FD na v\u0161echna mal\u00E1 p\u00EDsmena.
str_to_uppercase=Vrac\u00ED \u0159et\u011Bzec s p\u0159eveden\u00FD na v\u0161echna velk\u00E1 p\u00EDsmena.
str_trim=Vrac\u00ED kopii \u0159et\u011Bzce s s odstran\u011Bn\u00FDmi po\u010D\u00E1te\u010Dn\u00EDmi a koncov\u00FDmi mezerami.
str_unicode=Vrac\u00ED pole \u0159et\u011Bzc\u016F popisuj\u00EDc\u00EDch jednotliv\u00E9 znaky s v jejich pln\u00E9m unicode z\u00E1pisu.
str_unescape=Zru\u0161\u00ED escapov\u00E1n\u00ED s v zadan\u00E9m re\u017Eimu escapov\u00E1n\u00ED. Re\u017Eim m\u016F\u017Ee b\u00FDt jeden z n\u00E1sleduj\u00EDc\u00EDch: ''html'', ''xml'', ''csv'', ''url'', ''javascript''. V\u0161imn\u011Bte si, \u017Ee kolem zadan\u00E9ho re\u017Eimu jsou vy\u017Eadov\u00E1ny uvozovky.
str_unicode_type=Vrac\u00ED pole \u0159et\u011Bzc\u016F popisuj\u00EDc\u00EDch jednotliv\u00E9 znaky s podle jejich unicode typu.
xml_innerxml=Vrac\u00ED vnit\u0159n\u00ED prvky XML elementu XML. Nevrac\u00ED text p\u0159\u00EDmo uvnit\u0159 zvolen\u00E9ho XML elementu - pouze obsah jeho pod\u0159azen\u00FDch prvk\u016F. Pou\u017Eijte jej ve spojen\u00ED s parseXml() a select() pro poskytnut\u00ED prvku.
xml_owntext=Vr\u00E1t\u00ED pouze text p\u0159\u00EDmo uvnit\u0159 vybran\u00E9ho prvku XML nebo HTML, ignoruje text uvnit\u0159 pod\u0159azen\u00FDch prvk\u016F (pro tento \u00FA\u010Del pou\u017Eijte funkci innerXml()). Pou\u017Eijte ve spojen\u00ED s parserem a select() pro poskytnut\u00ED prvku.
xml_parent=Vrac\u00ED nad\u0159azen\u00FD uzel nebo null, pokud nad\u0159azen\u00FD uzel neexistuje. Pou\u017Eijte jej ve spojen\u00ED s parseHtml() a select() pro poskytnut\u00ED prvku.
xml_parsexml=P\u0159i zad\u00E1n\u00ED bu\u0148ky pln\u00E9 textu ve form\u00E1tu XML funkce parseXml() vr\u00E1t\u00ED \u00FApln\u00FD dokument XML a p\u0159id\u00E1 chyb\u011Bj\u00EDc\u00ED uzav\u00EDrac\u00ED zna\u010Dky.
xml_scripttext=Vrac\u00ED kombinovan\u00E1 data prvku HTML/XML. Data jsou nap\u0159. uvnit\u0159 tagu &lt;script&gt;.\nV\u0161imn\u011Bte si, \u017Ee data NEJSOU textem elementu.\nPro z\u00EDsk\u00E1n\u00ED textu, kter\u00FD by byl viditeln\u00FD pro u\u017Eivatele, pou\u017Eijte funkci htmlText() a pro obsah tag\u016F &lt;script&gt;, &lt;style&gt; atd. pou\u017Eijte funkci scriptText().\nFunkci scriptText() pou\u017E\u00EDvejte ve spojen\u00ED s funkcemi parseHtml() a select().
xml_xmlattr=Vrac\u00ED \u0159et\u011Bzec z atributu elementu XML nebo HTML. Pou\u017Eijte jej ve spojen\u00ED s parseHtml() nebo parseXml(), abyste nejprve uk\u00E1zali na prvek.
fun_coalesce=Vr\u00E1t\u00ED prvn\u00ED nenulov\u00FD objekt z \u0159ady objekt\u016F (co\u017E znamen\u00E1 libovoln\u00FD datov\u00FD typ - \u0159et\u011Bzec, datum, \u010D\u00EDslo, logick\u00E1 hodnota atd.).
fun_get=Pokud m\u00E1 o pojmenovan\u00E1 pole, vr\u00E1t\u00ED pole pojmenovan\u00E9 ''from'' z o. Pokud je o pole, vr\u00E1t\u00ED podpole o[from, to]. pokud je o \u0159et\u011Bzec, vr\u00E1t\u00ED o.substring(from, to).
fun_facet_count=Vr\u00E1t\u00ED po\u010Det faset odpov\u00EDdaj\u00EDc\u00ED zadan\u00E9 hodnot\u011B volby vyhled\u00E1n\u00EDm fasetov\u00E9ho v\u00FDrazu v hodnot\u011B volbyValue ve sloupciName.
fun_has_field=Vrac\u00ED boolean ud\u00E1vaj\u00EDc\u00ED, zda o m\u00E1 \u010Dlensk\u00E9 pole s n\u00E1zvem name.
fun_jsonize=Cituje hodnotu jako doslovnou hodnotu JSON.
fun_length=Vrac\u00ED d\u00E9lku \u0159et\u011Bzce s jako \u010D\u00EDslo nebo velikost pole a, tedy po\u010Det objekt\u016F uvnit\u0159 pole. Pole mohou b\u00FDt pr\u00E1zdn\u00E1, v takov\u00E9m p\u0159\u00EDpad\u011B funkce length() vr\u00E1t\u00ED 0.
fun_slice=P\u0159i zad\u00E1n\u00ED \u0159et\u011Bzce vr\u00E1t\u00ED pod\u0159et\u011Bzec za\u010D\u00EDnaj\u00EDc\u00ED od indexu znaku from a\u017E po index znaku to. Pokud je argument to vynech\u00E1n, bude v\u00FDstupem konec \u0159et\u011Bzce s. Pamatujte, \u017Ee indexy znak\u016F za\u010D\u00EDnaj\u00ED od nuly. Dan\u00E9 pole vr\u00E1t\u00ED d\u00EDl\u010D\u00ED pole od prvn\u00EDho zadan\u00E9ho indexu a\u017E po posledn\u00ED zadan\u00FD index v\u010Detn\u011B. Pokud je hodnota to vynech\u00E1na, rozum\u00ED se j\u00ED konec pole. Pouze pro slice.
fun_time_since_unix_epoch_to_date=Vr\u00E1t\u00ED \u010D\u00EDslo p\u0159eveden\u00E9 na datum na z\u00E1klad\u011B Unix Epoch Time. \u010C\u00EDslo m\u016F\u017Ee b\u00FDt Unix Epoch Time v jedn\u00E9 z n\u00E1sleduj\u00EDc\u00EDch podporovan\u00FDch jednotek: sekunda, milisekunda, mikrosekunda. V\u00FDchoz\u00ED hodnota je ''sekunda''.
fun_to_number=Vrac\u00ED \u0159et\u011Bzec p\u0159eveden\u00FD na \u010D\u00EDslo. Pokus\u00ED se p\u0159ev\u00E9st jin\u00E9 form\u00E1ty na \u0159et\u011Bzec a pot\u00E9 na \u010D\u00EDslo. Pokud je hodnota ji\u017E \u010D\u00EDslem, vr\u00E1t\u00ED \u010D\u00EDslo.
fun_type=Vrac\u00ED \u0159et\u011Bzec s datov\u00FDm typem o, nap\u0159\u00EDklad undefined, string, number, boolean atd.
str_match=Pokus\u00ED se porovnat cel\u00FD \u0159et\u011Bzec s s regexov\u00FDm vzorem p a v p\u0159\u00EDpad\u011B nalezen\u00ED vzoru vyp\u00ED\u0161e pole v\u0161ech zachycen\u00FDch skupin (nalezen\u00FDch v po\u0159ad\u00ED). Viz tak\u00E9 funkce find().
str_chomp=Vr\u00E1t\u00ED kopii \u0159et\u011Bzce s s \u0159et\u011Bzcem sep p\u0159e\u010Dten\u00FDm z konce, pokud s kon\u010D\u00ED sep; v opa\u010Dn\u00E9m p\u0159\u00EDpad\u011B vr\u00E1t\u00ED s.
str_contains=Vrac\u00ED logickou hodnotu ur\u010Duj\u00EDc\u00ED, zda s obsahuje sub, co\u017E je bu\u010F pod\u0159et\u011Bzec, nebo regexov\u00FD vzor. Nap\u0159\u00EDklad "food".contains("oo") vrac\u00ED true.
str_replace_chars=Vrac\u00ED \u0159et\u011Bzec z\u00EDskan\u00FD nahrazen\u00EDm znaku v s identifikovan\u00E9ho p\u0159\u00EDkazem find odpov\u00EDdaj\u00EDc\u00EDm znakem identifikovan\u00FDm p\u0159\u00EDkazem replace. Tuto funkci nelze pou\u017E\u00EDt k nahrazen\u00ED jednoho znaku v\u00EDce ne\u017E jedn\u00EDm znakem.
xml_wholetext=Vybere (nek\u00F3dovan\u00FD) text prvku a jeho pod\u0159azen\u00FDch prvk\u016F, v\u010Detn\u011B nov\u00FDch \u0159\u00E1dk\u016F a mezer, a vr\u00E1t\u00ED \u0159et\u011Bzec nek\u00F3dovan\u00E9ho, nenormalizovan\u00E9ho textu. Pou\u017Eijte jej ve spojen\u00ED s parseHtml() a select() pro poskytnut\u00ED prvku.
xml_selectxml=Vrac\u00ED pole v\u0161ech po\u017Eadovan\u00FDch prvk\u016F z dokumentu HTML nebo XML, pokud dan\u00FD prvek existuje. Prvky jsou identifikov\u00E1ny pomoc\u00ED syntaxe selektoru Jsoup: https://jsoup.org/apidocs/org/jsoup/select/Selector.html.
xml_xmltext=Vr\u00E1t\u00ED \u0159et\u011Bzec textu z prvku HTML nebo XML (v\u010Detn\u011B v\u0161ech pod\u0159\u00EDzen\u00FDch prvk\u016F), p\u0159i\u010Dem\u017E odstran\u00ED zna\u010Dky a zalomen\u00ED \u0159\u00E1dk\u016F uvnit\u0159 \u0159et\u011Bzce. Pou\u017Eijte ve spojen\u00ED s parseHtml() nebo parseXml() a select() pro poskytnut\u00ED prvku.
str_split_by_lengths=Vrac\u00ED pole \u0159et\u011Bzc\u016F z\u00EDskan\u00FDch rozd\u011Blen\u00EDm \u0159et\u011Bzce s na pod\u0159et\u011Bzce zadan\u00FDch d\u00E9lek. Nap\u0159\u00EDklad \u201Einternationalization\u201C.splitByLengths(5, 6, 3) vr\u00E1t\u00ED pole 3 \u0159et\u011Bzc\u016F: [\u201Einter\u201C, \u201Enation\u201C, \u201Eali\u201C ]. P\u0159ebyte\u010Dn\u00E9 znaky jsou z v\u00FDstupn\u00EDho pole vy\u0159azeny.
str_replace=Vrac\u00ED \u0159et\u011Bzec z\u00EDskan\u00FD nahrazen\u00EDm \u0159et\u011Bzce find \u0159et\u011Bzcem replace ve vlo\u017Een\u00E9m \u0159et\u011Bzci. Nap\u0159\u00EDklad ''he cow jumps over the moon and moos''.replace(''oo'', ''ee'') vr\u00E1t\u00ED \u0159et\u011Bzec ''The cow jumps over the meen and mees''. Find m\u016F\u017Ee b\u00FDt regexov\u00FD vzor. Nap\u0159\u00EDklad ''The cow jumps over the moon and moos''.replace(/\\s+/, \u201E_\u201C) vr\u00E1t\u00ED ''The_cow_jumps_over_the_moon_and_moos''
str_to_title_case=Vr\u00E1t\u00ED \u0159et\u011Bzec s p\u0159eveden\u00FD na titulkov\u00E9 p\u00EDsmeno: velk\u00E9 p\u00EDsmeno na za\u010D\u00E1tku ka\u017Ed\u00E9ho slova a ostatn\u00ED p\u00EDsmena mal\u00E1. Nap\u0159\u00EDklad ''Once upon a midnight DREARY''.toTitlecase() vr\u00E1t\u00ED \u0159et\u011Bzec ''Once Upon A Midnight Dreary''. Voliteln\u011B \u0159et\u011Bzec odd\u011Blovac\u00EDch znak\u016F, kter\u00E9 se pou\u017E\u00EDvaj\u00ED k odd\u011Blen\u00ED slov. Prvn\u00ED znak a prvn\u00ED neodd\u011Blovac\u00ED znak za odd\u011Blova\u010Dem budou ps\u00E1ny velk\u00FDmi p\u00EDsmeny. Nap\u0159\u00EDklad \u201Ejean-michel jarre\u201C.toTitlecase(\u201E -\u201C) vr\u00E1t\u00ED \u201EJean-Michel Jarre\u201C.
fun_cross=Vyhled\u00E1 zadanou hodnotu v c\u00EDlov\u00E9m sloupci c\u00EDlov\u00E9ho projektu a vr\u00E1t\u00ED pole odpov\u00EDdaj\u00EDc\u00EDch \u0159\u00E1dk\u016F. Dv\u011B hodnoty se shoduj\u00ED pouze tehdy, pokud maj\u00ED stejnou \u0159et\u011Bzcovou reprezentaci. Prvn\u00ED argument bude interpretov\u00E1n jako cell.value, pokud je nastaven na hodnotu cell. Druh\u00FD argument bude interpretov\u00E1n jako n\u00E1zev aktu\u00E1ln\u00EDho projektu, pokud bude vynech\u00E1n nebo nastaven na "". T\u0159et\u00ED argument bude interpretov\u00E1n jako index (za\u010D\u00EDn\u00E1 od 0) sloupce, pokud je vynech\u00E1n nebo nastaven na "".
fun_to_date=Vr\u00E1t\u00ED zadan\u00FD objekt p\u0159eveden\u00FD na objekt data. Bez argument\u016F vr\u00E1t\u00ED roz\u0161\u00ED\u0159en\u00FD form\u00E1t ISO 8601. Pomoc\u00ED argument\u016F m\u016F\u017Eete ovl\u00E1dat v\u00FDstupn\u00ED form\u00E1t. With monthFirst: nastavte false, pokud je datum naform\u00E1tov\u00E1no na den p\u0159ed m\u011Bs\u00EDcem. S formatN: pokuste se analyzovat datum pomoc\u00ED se\u0159azen\u00E9ho seznamu mo\u017En\u00FDch form\u00E1t\u016F. Dod\u00E1vejte form\u00E1ty zalo\u017Een\u00E9 na syntaxi SimpleDateFormat: <a href="http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html">SimpleDateFormat</a>.
fun_to_string=P\u0159ij\u00EDm\u00E1 libovoln\u00FD typ hodnoty (\u0159et\u011Bzec, \u010D\u00EDslo, datum, boolean, chyba, null) a poskytuje \u0159et\u011Bzcovou verzi t\u00E9to hodnoty. \u010C\u00EDsla lze p\u0159ev\u00E1d\u011Bt na \u0159et\u011Bzce se zaokrouhlov\u00E1n\u00EDm pomoc\u00ED voliteln\u00E9ho form\u00E1tu \u0159et\u011Bzce. Viz https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html. Na \u0159et\u011Bzce m\u016F\u017Eete p\u0159ev\u00E1d\u011Bt tak\u00E9 data pomoc\u00ED syntaxe pro rozbor data. Viz https://openrefine.org/docs/manual/grelfunctions/#date-functions.
